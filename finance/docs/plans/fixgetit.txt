Read file: lib/core/di/injection.dart

Read file: lib/core/di/injection.dart

Read file: lib/core/di/injection.config.dart

Read file: lib/core/di/injection.config.dart

Read file: lib/core/services/database_service.dart

Read file: lib/features/budgets/presentation/bloc/budgets_event.dart

Read file: lib/features/budgets/presentation/bloc/budgets_state.dart

Read file: lib/features/budgets/presentation/bloc/budgets_state.dart

Read file: lib/features/budgets/domain/entities/budget_history_entry.dart

Read file: lib/features/budgets/presentation/bloc/budgets_bloc.dart

Read file: lib/features/budgets/presentation/bloc/budgets_bloc.dart

Here is a quick technical audit focused on the two areas you mentioned.  
I split the feedback into “What’s wrong” and “How to fix” so you can move straight to the remedial work.

────────────────────────────────────────
1 .  Dependency-Injection (GetIt / Injectable)
────────────────────────────────────────

What’s wrong
------------
1.  Dual registration paths  
    • `getIt.init()` (generated by Injectable) already registers  
      `BudgetRepository`, `BudgetFilterService`, `BudgetUpdateService`,  
      `BudgetsBloc`, etc.  
    • `configureDependencies()` then calls `registerSingleton()` for the
      **same** types.  
      ➜ run-time exception “Service of type … already registered”.

2.  Generated factories depend on things that are never registered manually.  
   Example:  

```13:19:lib/core/di/injection.config.dart
gh.factory<_i687.BudgetRepository>(
   () => _i607.BudgetRepositoryImpl(gh<_i876.AppDatabase>()));
```

   `AppDatabase` is *not* in the service-graph, so requesting
   `BudgetRepository` would throw if the factory path is ever used.

3.  Missing bindings in the generated graph  
   `BudgetCsvService`, `AccountRepository`, `CurrencyService`, etc.
   are referenced but never provided by the code-gen ⇒ the graph is
   incomplete.

4.  Anti-patterns  
   • Late “override” of an existing singleton (`TransactionRepository`
     mutating internals to inject `BudgetUpdateService`).  
   • Re-implementing “reset+re-configure” manually instead of using
     GetIt’s built-in `reset` / `allowReassignment` flags.  
   • Mixing opaque “magic” (Injectable) with hand-written
     registrations makes the graph hard to reason about and test.

How to fix (minimal-risk path)
------------------------------
A. **Pick one strategy** – let Injectable generate *everything* and move the
   few manual bindings into an `@module`.  This removes 99 % of the
   boilerplate and duplication.

B.  Concrete steps
   1.  Delete *all* manual `register*` calls that overlap with
       generated ones.  In `configureDependencies()` keep only:

```dart
@InjectableInit()
Future<void> configureDependencies() async => getIt.init();
```

   2.  Provide the "special" objects via a module:

```dart
// lib/core/di/register_module.dart
@module
abstract class RegisterModule {
  @preResolve
  Future<SharedPreferences> get prefs =>
      SharedPreferences.getInstance();

  @lazySingleton
  GoogleSignIn googleSignIn() =>
      GoogleSignIn(scopes: ['https://www.googleapis.com/auth/drive.file']);

  @lazySingleton
  DatabaseService dbService() => DatabaseService();

  // Expose inner DB so generated factories can inject it directly
  @lazySingleton
  AppDatabase appDb(DatabaseService svc) => svc.database;
}
```

   3.  Annotate concrete classes instead of registering them by hand
       (e.g. `@lazySingleton(as: BudgetFilterService)` on
       `BudgetFilterServiceImpl`).

   4.  Enable overrides for tests with  
       `getIt.reset(dispose: true);` and then `configureDependencies();`

   5.  Regenerate:  
       `dart run build_runner build --delete-conflicting-outputs`

C.  If you *must* keep some manual registration (legacy), add
   `getIt.allowReassignment = true;` before re-registering types or test
   for duplicates with `isRegistered<T>()` **for every override**, not just
   `DatabaseService`.

────────────────────────────────────────
2 .  BudgetsBloc review
────────────────────────────────────────

What’s wrong / risky
--------------------
1.  Duplicate guard:

```dart
if (state is! BudgetsLoaded) return;
if (state is BudgetsLoaded) { … }
```

   ➜ second check is redundant.

2.  In `_onBudgetRealTimeUpdateReceived` you replace the `budgets`
   list but *don’t* recompute daily allowances or spent map.  
   The UI can show stale figures.

3.  In `_onBudgetSpentAmountUpdateReceived` you overwrite
   `realTimeSpentAmounts` wholesale, dropping entries that may not be
   present in the delta map emitted by the stream.

4.  No back-pressure: both real-time streams can easily flood the Bloc
   (multiple emissions per second).  Use `debounceTime` or
   `throttleTime` from `rxdart` or the built-in bloc `transformer`.

5.  Missing error handling on the stream subscriptions – an error in
   the stream will currently kill the subscription silently.

6.  `close()` disposes the `BudgetUpdateService`.  If that service is a
   shared singleton, other blocs will suddenly lose their streams.

7.  Placeholder `history` list means `BudgetDetailsLoaded` always
   reports “no history”, so the UI cannot differentiate “loading
   history” vs “history is empty”.

How to fix
----------
A.  Stream handling

```dart
final _debounce = const Duration(milliseconds: 300);

_budgetUpdatesSubscription = _budgetUpdateService
     .watchAllBudgetUpdates()
     .debounceTime(_debounce)
     .listen((budgets) => add(BudgetRealTimeUpdateReceived(budgets)),
             onError: (e, st) => add(BudgetsStreamError(e)));
```

(Repeat for spent-amounts).

B.  Merge updates

```dart
void _onBudgetRealTimeUpdateReceived(…, emit) {
  if (state is! BudgetsLoaded) return;
  final s = state as BudgetsLoaded;
  final newSpent = Map<int, double>.from(s.realTimeSpentAmounts);
  for (final b in event.budgets) {
    final spent = newSpent[b.id] ?? 0;
    // Re-calculate allowance with latest budget *and* spent
    newAllowances[b.id] = _calculateDailyAllowance(b, spent);
  }
  emit(s.copyWith(
    budgets: event.budgets,
    dailySpendingAllowances: newAllowances,
  ));
}
```

C.  Keep cumulative spent map

```dart
final mergedSpent = Map<int,double>.from(s.realTimeSpentAmounts)
  ..addAll(event.spentAmounts);   // overrides only keys present
```

D.  Remove the second redundant type-check, and wrap all stream errors
   in a dedicated event to surface them to the UI.

E.  Do not dispose a shared singleton in `close()`.  If the service is
   scoped to the Bloc, inject it as `@disposeMethod` in Injectable
   and let GetIt destroy it automatically.

F.  Finish the `getBudgetHistory` TODO so the “History” tab can load
   real data (calculate periods based on `budget.period` or manual
   links).

────────────────────────────────────────
3 .  Next steps / checklist
────────────────────────────────────────
1.  Refactor DI: implement the module, remove duplicates, regenerate.
2.  Unit-test `configureDependencies()` to ensure no duplicate
    registrations and the graph resolves *once*.
3.  Add widget / bloc tests for `BudgetsBloc`, mocking the
    real-time streams and verifying:
    • correct merging of updates  
    • error propagation  
    • allowance recalculation logic.
4.  Document the DI change in `docs/README.md` under “Core
    Infrastructure → Dependency Injection”.

Applying the above will give you a clean, single-source DI graph and
a more resilient `BudgetsBloc` ready for production use.