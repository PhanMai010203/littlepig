# Transaction Management System - Usage Guide

## Basic Setup

```dart
import 'package:finance/features/transactions/domain/repositories/transaction_repository.dart';
import 'package:finance/features/transactions/domain/repositories/attachment_repository.dart';
import 'package:finance/features/transactions/domain/entities/transaction.dart';
import 'package:finance/features/transactions/domain/entities/transaction_enums.dart';
import 'package:finance/features/transactions/domain/entities/attachment.dart';
import 'package:finance/features/categories/domain/repositories/category_repository.dart';
import 'package:finance/features/accounts/domain/repositories/account_repository.dart';
import 'package:finance/core/services/file_picker_service.dart';
import 'package:finance/core/di/injection.dart';

// Get the repositories and services
final transactionRepository = getIt<TransactionRepository>();
final attachmentRepository = getIt<AttachmentRepository>();
final categoryRepository = getIt<CategoryRepository>();
final accountRepository = getIt<AccountRepository>();
final filePickerService = getIt<FilePickerService>();
```

## Retrieving Transactions

### Get All Transactions
```dart
// Get all transactions in the system
final transactions = await transactionRepository.getAllTransactions();
print('Found ${transactions.length} transactions');
```

### Get Transactions by Account
```dart
// Get all transactions for a specific account
final accountTransactions = await transactionRepository.getTransactionsByAccount(accountId);
```

### Get Transactions by Category
```dart
// Get all transactions for a specific category
final categoryTransactions = await transactionRepository.getTransactionsByCategory(categoryId);
```

### Get Transactions by Date Range
```dart
// Get transactions within a specific date range
final startDate = DateTime(2024, 1, 1);
final endDate = DateTime(2024, 12, 31);
final dateRangeTransactions = await transactionRepository.getTransactionsByDateRange(
  startDate,
  endDate,
);
```

### Get Specific Transaction
```dart
// Get transaction by ID
final transaction = await transactionRepository.getTransactionById(transactionId);
if (transaction != null) {
  print('Transaction: ${transaction.title} - ${transaction.amount}');
}

// Get transaction by sync ID (for sync operations)
final syncTransaction = await transactionRepository.getTransactionBySyncId(syncId);
```

## Creating Transactions

### Basic Transaction Creation with Notes
```dart
// Create a new expense transaction with note
final expense = Transaction(
  title: 'Lunch at Restaurant',
  note: 'Had lunch with colleagues at downtown restaurant - Remember to expense this for the client meeting',
  amount: -25.50, // Negative for expenses
  categoryId: foodCategoryId,
  accountId: mainAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '', // Will be generated by repository
  version: 1,
);

final createdTransaction = await transactionRepository.createTransaction(expense);
print('Created transaction with ID: ${createdTransaction.id}');
```

### Create Income Transaction
```dart
// Create a new income transaction
final income = Transaction(
  title: 'Monthly Salary',
  note: 'Salary payment from company - Includes bonus for Q4 performance',
  amount: 3500.00, // Positive for income
  categoryId: salaryCategoryId,
  accountId: bankAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '',
  version: 1,
);

final createdIncome = await transactionRepository.createTransaction(income);
```

### Create Transaction with Full Details
```dart
// Create transaction with all optional fields
final detailedTransaction = Transaction(
  title: 'Grocery Shopping',
  note: 'Weekly grocery shopping at SuperMart\\nItems: milk, bread, fruits\\nUsed 10% discount coupon - saved $8.50',
  amount: -85.75,
  categoryId: groceryCategoryId,
  accountId: creditCardAccountId,
  date: DateTime(2024, 6, 15, 14, 30), // Specific date and time
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'phone-device-123',
  isSynced: false,
  syncId: '',
  version: 1,
);

await transactionRepository.createTransaction(detailedTransaction);
```

## Working with Attachments

### Adding Attachments to Transactions

The attachment system follows this flow:
1. User chooses attachment source (camera, gallery, or file picker)
2. Files are compressed if they are images
3. Files are uploaded to Google Drive
4. Google Drive links are generated and stored

```dart
// Check if user can add attachments (Google Drive authorization)
if (!await filePickerService.canAddAttachments()) {
  // Request Google Drive authorization
  final authorized = await filePickerService.requestGoogleDriveAuthorization();
  if (!authorized) {
    print('Google Drive authorization is required to add attachments');
    return;
  }
}

// Add attachments to a transaction
try {
  final attachments = await filePickerService.addAttachments(transactionId);
  print('Added ${attachments.length} attachments to transaction');
  
  for (final attachment in attachments) {
    print('Attachment: ${attachment.fileName} (${attachment.type})');
    if (attachment.googleDriveLink != null) {
      print('View at: ${attachment.googleDriveLink}');
    }
  }
} catch (e) {
  print('Failed to add attachments: $e');
}
```

### Manual Attachment Management

#### Get Attachments for a Transaction
```dart
// Get all attachments for a specific transaction
final attachments = await attachmentRepository.getAttachmentsByTransaction(transactionId);
print('Found ${attachments.length} attachments');

for (final attachment in attachments) {
  print('${attachment.fileName}: ${attachment.isAvailable ? "Available" : "Not available"}');
}
```

#### Create Attachment Manually
```dart
// Create attachment manually (for advanced use cases)
final attachment = Attachment(
  transactionId: transactionId,
  fileName: 'receipt.jpg',
  filePath: '/path/to/local/file.jpg',
  type: AttachmentType.image,
  mimeType: 'image/jpeg',
  fileSizeBytes: 1024000,
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  isUploaded: false,
  isDeleted: false,
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: 'unique-attachment-id',
  version: 1,
);

final createdAttachment = await attachmentRepository.createAttachment(attachment);

// Upload to Google Drive
await attachmentRepository.uploadToGoogleDrive(createdAttachment);
```

#### Delete Attachments
```dart
// Delete attachment (moves to Google Drive trash automatically)
await filePickerService.deleteAttachment(attachmentId);

// Or manually mark as deleted
await attachmentRepository.markAsDeleted(attachmentId);
```

### Working with Different Attachment Types
```dart
// Check attachment properties
if (attachment.isImage) {
  print('This is an image attachment');
} else if (attachment.isDocument) {
  print('This is a document attachment');
}

// Check if attachment is available for viewing
if (attachment.isAvailable) {
  print('Attachment can be viewed at: ${attachment.googleDriveLink}');
} else {
  print('Attachment is not available (deleted or not uploaded)');
}
```

## Updating Transactions

### Basic Update with Notes
```dart
// Update an existing transaction
final updatedTransaction = existingTransaction.copyWith(
  title: 'Updated Title',
  amount: -30.00,
  note: 'Updated notes with additional information about this transaction',
);

final result = await transactionRepository.updateTransaction(updatedTransaction);
```

### Update Category or Account
```dart
// Move transaction to different category or account
final recategorized = transaction.copyWith(
  categoryId: newCategoryId,
  accountId: newAccountId,
  note: 'Recategorized from ${oldCategoryName} to ${newCategoryName}',
);

await transactionRepository.updateTransaction(recategorized);
```

### Update Amount
```dart
// Correct transaction amount
final correctedAmount = transaction.copyWith(
  amount: -45.99, // Corrected amount
  note: 'Corrected amount from original ${transaction.amount}',
);

await transactionRepository.updateTransaction(correctedAmount);
```

## Deleting Transactions

### Delete Transaction and Its Attachments
```dart
// Get all attachments for the transaction first
final attachments = await attachmentRepository.getAttachmentsByTransaction(transactionId);

// Delete all attachments (moves files to Google Drive trash)
for (final attachment in attachments) {
  await filePickerService.deleteAttachment(attachment.id!);
}

// Delete the transaction
await transactionRepository.deleteTransaction(transactionId);
```

## Transaction Analytics

### Get Total by Category
```dart
// Get total spending for a category (all time)
final categoryTotal = await transactionRepository.getTotalByCategory(
  foodCategoryId,
  null, // from date
  null, // to date
);

// Get category total for specific period
final monthlyFoodSpending = await transactionRepository.getTotalByCategory(
  foodCategoryId,
  DateTime(2024, 6, 1), // June 1st
  DateTime(2024, 6, 30), // June 30th
);
```

### Get Total by Account
```dart
// Get total transactions for an account
final accountTotal = await transactionRepository.getTotalByAccount(
  accountId,
  DateTime(2024, 1, 1), // Year start
  DateTime(2024, 12, 31), // Year end
);
```

### Get Spending by Categories
```dart
// Get spending breakdown by all categories
final spendingBreakdown = await transactionRepository.getSpendingByCategory(
  DateTime(2024, 6, 1),
  DateTime(2024, 6, 30),
);

// spendingBreakdown is Map<int, double> where key is categoryId
for (final entry in spendingBreakdown.entries) {
  final categoryId = entry.key;
  final amount = entry.value;
  print('Category $categoryId: ${amount.toStringAsFixed(2)}');
}
```

## Transaction Properties

### Check Transaction Type
```dart
// Use built-in properties to check transaction type
if (transaction.isIncome) {
  print('This is an income transaction');
}

if (transaction.isExpense) {
  print('This is an expense transaction');
}

// Manual check
if (transaction.amount > 0) {
  print('Income: +${transaction.amount}');
} else {
  print('Expense: ${transaction.amount}');
}
```

### Access Transaction Details
```dart
// Access all transaction properties including notes
print('ID: ${transaction.id}');
print('Title: ${transaction.title}');
print('Note: ${transaction.note ?? 'No additional notes'}');
print('Amount: ${transaction.amount}');
print('Date: ${transaction.date}');
print('Created: ${transaction.createdAt}');
print('Updated: ${transaction.updatedAt}');
print('Category ID: ${transaction.categoryId}');
print('Account ID: ${transaction.accountId}');
print('Sync Status: ${transaction.isSynced}');
```

## Google Drive Integration

### Authorization Management
```dart
// Check if user is signed in to Google Drive
final isSignedIn = await filePickerService.canAddAttachments();
print('Google Drive authorized: $isSignedIn');

// Request authorization if needed
if (!isSignedIn) {
  final authorized = await filePickerService.requestGoogleDriveAuthorization();
  if (authorized) {
    print('Google Drive authorization successful');
  } else {
    print('Google Drive authorization failed');
  }
}
```

### Managing Google Drive Files
```dart
// Get Google Drive download link for an attachment
final downloadLink = await attachmentRepository.getGoogleDriveDownloadLink(
  attachment.googleDriveFileId!,
);

if (downloadLink != null) {
  print('View file at: $downloadLink');
}

// Delete file from Google Drive (moves to trash)
await attachmentRepository.deleteFromGoogleDrive(attachment.googleDriveFileId!);
```

## Sync Operations

### Get Unsynced Data
```dart
// Get transactions that haven't been synced to cloud
final unsyncedTransactions = await transactionRepository.getUnsyncedTransactions();
print('${unsyncedTransactions.length} transactions need syncing');

// Get attachments that haven't been synced
final unsyncedAttachments = await attachmentRepository.getUnsyncedAttachments();
print('${unsyncedAttachments.length} attachments need syncing');
```

### Mark as Synced
```dart
// Mark transaction as synced (typically done by sync service)
await transactionRepository.markAsSynced(
  transaction.syncId,
  DateTime.now(),
);

// Mark attachment as synced
await attachmentRepository.markAsSynced(
  attachment.syncId,
  DateTime.now(),
);
```

### Insert from Sync
```dart
// Insert or update transaction from cloud sync
await transactionRepository.insertOrUpdateFromSync(remoteTransaction);

// Insert or update attachment from cloud sync
await attachmentRepository.insertOrUpdateFromSync(remoteAttachment);
```

## Advanced Usage

### Working with Transactions and Their Attachments
```dart
// Get transaction with all its attachments
final transaction = await transactionRepository.getTransactionById(id);
final attachments = await attachmentRepository.getAttachmentsByTransaction(id);

if (transaction != null) {
  final category = await categoryRepository.getCategoryById(transaction.categoryId);
  final account = await accountRepository.getAccountById(transaction.accountId);
  
  print('${transaction.title}');
  print('Notes: ${transaction.note ?? 'None'}');
  print('Category: ${category?.name} ${category?.icon}');
  print('Account: ${account?.name} (${account?.currency})');
  print('Amount: ${transaction.amount}');
  print('Attachments: ${attachments.length}');
  
  for (final attachment in attachments) {
    print('  - ${attachment.fileName} (${attachment.type.name})');
    if (attachment.isAvailable) {
      print('    View: ${attachment.googleDriveLink}');
    }
  }
}
```

### Batch Operations
```dart
// Process multiple transactions with their attachments
final transactions = await transactionRepository.getAllTransactions();
for (final transaction in transactions) {
  if (transaction.amount < 0 && transaction.amount.abs() > 100) {
    final attachments = await attachmentRepository.getAttachmentsByTransaction(transaction.id!);
    print('Large expense: ${transaction.title} - ${transaction.amount}');
    print('  Notes: ${transaction.note ?? 'No notes'}');
    print('  Attachments: ${attachments.length}');
  }
}
```

### Filter Transactions
```dart
// Filter transactions by criteria
final allTransactions = await transactionRepository.getAllTransactions();

// Filter by amount range
final largeTransactions = allTransactions.where(
  (t) => t.amount.abs() > 50
).toList();

// Filter by date
final recentTransactions = allTransactions.where(
  (t) => t.date.isAfter(DateTime.now().subtract(Duration(days: 7)))
).toList();

// Filter by type
final incomeTransactions = allTransactions.where((t) => t.isIncome).toList();
final expenseTransactions = allTransactions.where((t) => t.isExpense).toList();

// Filter transactions with notes
final transactionsWithNotes = allTransactions.where(
  (t) => t.note != null && t.note!.isNotEmpty
).toList();
```

## Error Handling

### Handle Repository Errors
```dart
try {
  final transaction = await transactionRepository.createTransaction(newTransaction);
  print('Transaction created successfully');
} catch (e) {
  print('Failed to create transaction: $e');
  // Handle error - maybe show user feedback
}

try {
  final attachments = await filePickerService.addAttachments(transactionId);
  print('Attachments added successfully');
} catch (e) {
  print('Failed to add attachments: $e');
  // Maybe user denied Google Drive permission or file access
}
```

### Validate Before Operations
```dart
// Validate transaction data before creating
bool isValidTransaction(Transaction transaction) {
  if (transaction.title.trim().isEmpty) return false;
  if (transaction.amount == 0) return false;
  if (transaction.categoryId <= 0) return false;
  if (transaction.accountId <= 0) return false;
  return true;
}

if (isValidTransaction(newTransaction)) {
  await transactionRepository.createTransaction(newTransaction);
} else {
  print('Invalid transaction data');
}
```

## Best Practices

1. **Always Set Device ID**: Ensure transactions have proper device ID for sync
2. **Use Descriptive Titles**: Make transaction purposes clear
3. **Leverage Notes Field**: Use notes for additional context and information
4. **Consistent Amount Signs**: Negative for expenses, positive for income
5. **Handle Sync Status**: Check sync status for conflict resolution
6. **Validate Categories/Accounts**: Ensure referenced IDs exist
7. **Use Date Ranges**: Optimize queries with date filtering
8. **Batch Analytics**: Use repository analytics methods instead of manual calculations
9. **Google Drive Authorization**: Always check authorization before adding attachments
10. **Handle File Failures Gracefully**: Implement proper error handling for file operations

## Common Patterns

### Transaction Form Validation
```dart
class TransactionValidator {
  static String? validateTitle(String? title) {
    if (title == null || title.trim().isEmpty) {
      return 'Title is required';
    }
    if (title.length > 255) {
      return 'Title too long';
    }
    return null;
  }
  
  static String? validateAmount(String? amount) {
    if (amount == null || amount.isEmpty) {
      return 'Amount is required';
    }
    final value = double.tryParse(amount);
    if (value == null || value == 0) {
      return 'Invalid amount';
    }
    return null;
  }
  
  static String? validateNote(String? note) {
    if (note != null && note.length > 1000) {
      return 'Note too long (max 1000 characters)';
    }
    return null;
  }
}
```

### Transaction List Widget Helper
```dart
// Helper for displaying transactions in UI
String formatTransactionForDisplay(Transaction transaction) {
  final sign = transaction.isIncome ? '+' : '';
  final amount = '${sign}${transaction.amount.toStringAsFixed(2)}';
  final date = DateFormat('MMM dd, yyyy').format(transaction.date);
  final hasAttachments = transaction.id != null; // Would need to check in real scenario
  final attachmentIndicator = hasAttachments ? '📎' : '';
  final noteIndicator = transaction.note?.isNotEmpty == true ? '📝' : '';
  
  return '${transaction.title} • $amount • $date $attachmentIndicator$noteIndicator';
}
```

### Monthly Spending Analysis with Attachments
```dart
// Analyze spending for current month including attachment information
Future<Map<String, dynamic>> getMonthlySpendingAnalysis() async {
  final now = DateTime.now();
  final monthStart = DateTime(now.year, now.month, 1);
  final monthEnd = DateTime(now.year, now.month + 1, 0);
  
  final spendingByCategory = await transactionRepository.getSpendingByCategory(
    monthStart,
    monthEnd,
  );
  
  final allTransactions = await transactionRepository.getTransactionsByDateRange(
    monthStart,
    monthEnd,
  );
  
  // Count transactions with attachments
  int transactionsWithAttachments = 0;
  for (final transaction in allTransactions) {
    final attachments = await attachmentRepository.getAttachmentsByTransaction(transaction.id!);
    if (attachments.isNotEmpty) {
      transactionsWithAttachments++;
    }
  }
  
  // Convert category IDs to names
  final categorySpending = <String, double>{};
  for (final entry in spendingByCategory.entries) {
    final category = await categoryRepository.getCategoryById(entry.key);
    if (category != null) {
      categorySpending[category.name] = entry.value.abs();
    }
  }
  
  return {
    'spending_by_category': categorySpending,
    'total_transactions': allTransactions.length,
    'transactions_with_attachments': transactionsWithAttachments,
    'attachment_percentage': allTransactions.isNotEmpty 
        ? (transactionsWithAttachments / allTransactions.length * 100).toStringAsFixed(1)
        : '0',
  };
}
```

### Transaction Search with Notes and Attachments
```dart
// Search transactions by title or notes
Future<List<Transaction>> searchTransactions(String query) async {
  final allTransactions = await transactionRepository.getAllTransactions();
  final searchQuery = query.toLowerCase();
  
  return allTransactions.where((transaction) {
    final title = transaction.title.toLowerCase();
    final note = (transaction.note ?? '').toLowerCase();
    
    return title.contains(searchQuery) || 
           note.contains(searchQuery);
  }).toList();
}

// Search transactions with attachments of specific type
Future<List<Transaction>> searchTransactionsWithImages() async {
  final allTransactions = await transactionRepository.getAllTransactions();
  final transactionsWithImages = <Transaction>[];
  
  for (final transaction in allTransactions) {
    final attachments = await attachmentRepository.getAttachmentsByTransaction(transaction.id!);
    final hasImages = attachments.any((attachment) => attachment.isImage);
    
    if (hasImages) {
      transactionsWithImages.add(transaction);
    }
  }
  
  return transactionsWithImages;
}
```

### Attachment Management Widget Helper
```dart
// Helper for managing attachments in UI
class AttachmentHelper {
  static String getAttachmentIcon(AttachmentType type) {
    switch (type) {
      case AttachmentType.image:
        return '🖼️';
      case AttachmentType.document:
        return '📄';
      case AttachmentType.other:
        return '📎';
    }
  }
  
  static String formatFileSize(int? bytes) {
    if (bytes == null) return 'Unknown size';
    
    if (bytes < 1024) {
      return '${bytes}B';
    } else if (bytes < 1024 * 1024) {
      return '${(bytes / 1024).toStringAsFixed(1)}KB';
    } else {
      return '${(bytes / (1024 * 1024)).toStringAsFixed(1)}MB';
    }
  }
  
  static Color getAttachmentStatusColor(Attachment attachment) {
    if (!attachment.isAvailable) return Colors.red;
    if (!attachment.isUploaded) return Colors.orange;
    return Colors.green;
  }
}
```

## Attachment Flow Implementation

The attachment system follows this specific flow as requested:

```
flowchart TD
    A[User wants to add attachments when adding transaction] --> B{Choose attachment option}
    
    B --> C[Take Photo]
    B --> D[Select Photo]  
    B --> E[Select File]
    
    C --> F[Open built-in camera]
    D --> G[Open gallery picker]
    E --> H[Open file picker]
    
    F --> I[Photo captured]
    G --> J[Photo selected from gallery]
    H --> K[File selected]
    
    I --> L{Is file a photo?}
    J --> L
    K --> L
    
    L -->|Yes| M[Compress photo file for Google Drive storage]
    L -->|No| N[Proceed without compression]
    
    M --> O[Upload file to Google Drive]
    N --> O
    
    O --> P[Generate Google Drive link]
    P --> Q[Store link for user to view later]
    
    Q --> R{User deletes attachment?}
    R -->|Yes| S[Move file to Google Drive trash automatically]
    R -->|No| T[End - File remains accessible]
    
    S --> U[End - File moved to trash]
```

This implementation provides a complete solution for transaction management with:
- **Note field**: Additional to description for extra context
- **Multiple attachments**: Full Google Drive integration
- **Automatic compression**: For images to save storage
- **Clean Architecture**: Following the established patterns
- **Error handling**: Comprehensive error management
- **Sync support**: Full cloud synchronization capabilities

The system requires Google Drive authorization but handles the entire flow automatically once authorized.

## Advanced Transaction Features (Phase 1)

The transaction system now supports advanced features including:
- **Notes Field**: A unified field for additional transaction information and context
- **Subscriptions/Recurring Payments**: Automatic recurring transactions
- **Loan System**: Credit/debt tracking with collection/settlement
- **Transaction States**: Pending, scheduled, completed, cancelled, action required
- **Advanced Actions**: Pay, skip, collect, settle based on transaction state

### Transaction Types

```dart
enum TransactionType {
  income,       // Regular income transaction
  expense,      // Regular expense transaction  
  transfer,     // Transfer between accounts (future use)
  subscription, // Subscription or recurring payment
  loan,         // Loan-related transaction (credit/debt)
  adjustment,   // Adjustment or correction transaction
}
```

### Special Transaction Types (for Loans)

```dart
enum TransactionSpecialType {
  credit, // Money lent to someone else
  debt,   // Money borrowed from someone else
}
```

### Recurrence Patterns

```dart
enum TransactionRecurrence {
  none,    // No recurrence (one-time transaction)
  daily,   // Recurring daily
  weekly,  // Recurring weekly
  monthly, // Recurring monthly
  yearly,  // Recurring yearly
}
```

### Transaction States

```dart
enum TransactionState {
  completed,      // Regular completed transaction
  pending,        // Pending transaction (not yet processed)
  scheduled,      // Scheduled for future (recurring transactions)
  cancelled,      // Cancelled transaction
  actionRequired, // Transaction that needs action (loan collection/settlement)
}
```

### Available Actions

```dart
enum TransactionAction {
  none,     // No action available
  pay,      // Pay a pending transaction
  skip,     // Skip a scheduled transaction
  unpay,    // Unpay a paid transaction (reverse)
  collect,  // Collect money (for credit transactions)
  settle,   // Settle debt (for debt transactions)
  edit,     // Edit transaction details
  delete,   // Delete transaction
}
```

## Creating Advanced Transactions

### Create Subscription/Recurring Transaction

```dart
// Create a monthly subscription
final subscription = Transaction(
  title: 'Netflix Subscription',
  note: 'Monthly video streaming service',
  amount: -9.99,
  categoryId: entertainmentCategoryId,
  accountId: bankAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '',
  version: 1,
  
  // Advanced fields for subscription
  transactionType: TransactionType.subscription,
  recurrence: TransactionRecurrence.monthly,
  periodLength: 1, // Every 1 month
  endDate: DateTime.now().add(Duration(days: 365)), // Auto-cancel after 1 year
  transactionState: TransactionState.scheduled,
  paid: false,
);

final createdSubscription = await transactionRepository.createTransaction(subscription);
```

### Create Credit Transaction (Money Lent)

```dart
// Create a transaction for money lent to someone
final creditTransaction = Transaction(
  title: 'Money Lent to John',
  note: 'Lent money for car repair - To be repaid by end of month',
  amount: -500.00, // Negative because money is leaving your account
  categoryId: personalCategoryId,
  accountId: savingsAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '',
  version: 1,
  
  // Advanced fields for credit
  transactionType: TransactionType.loan,
  specialType: TransactionSpecialType.credit,
  transactionState: TransactionState.actionRequired,
  paid: true, // Initially true (money was given out)
);

final createdCredit = await transactionRepository.createTransaction(creditTransaction);
```

### Create Debt Transaction (Money Borrowed)

```dart
// Create a transaction for money borrowed from someone
final debtTransaction = Transaction(
  title: 'Money Borrowed from Jane',
  note: 'Emergency fund for medical expenses - Need to repay with 5% interest',
  amount: 1000.00, // Positive because money is coming into your account
  categoryId: personalCategoryId,
  accountId: bankAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '',
  version: 1,
  
  // Advanced fields for debt
  transactionType: TransactionType.loan,
  specialType: TransactionSpecialType.debt,
  transactionState: TransactionState.actionRequired,
  paid: true, // Initially true (money was received)
);

final createdDebt = await transactionRepository.createTransaction(debtTransaction);
```

## Working with Advanced Transaction Properties

### Check Transaction Type and State

```dart
// Check transaction type
if (transaction.isSubscription) {
  print('This is a subscription');
}

if (transaction.isRecurring) {
  print('This transaction repeats');
}

if (transaction.isLoan) {
  print('This is a loan transaction');
}

if (transaction.isCredit) {
  print('Money was lent out');
}

if (transaction.isDebt) {
  print('Money was borrowed');
}

// Check transaction state
if (transaction.isPending) {
  print('Transaction is pending');
}

if (transaction.isScheduled) {
  print('Transaction is scheduled for future');
}

if (transaction.needsAction) {
  print('Transaction requires action (collect/settle)');
}
```

### Get Available Actions

```dart
// Get actions available for a transaction
final actions = transaction.availableActions;

for (final action in actions) {
  switch (action) {
    case TransactionAction.pay:
      print('Can pay this transaction');
      break;
    case TransactionAction.collect:
      print('Can collect money (for credit)');
      break;
    case TransactionAction.settle:
      print('Can settle debt');
      break;
    case TransactionAction.edit:
      print('Can edit transaction');
      break;
    case TransactionAction.delete:
      print('Can delete transaction');
      break;
    default:
      print('Action: ${action.name}');
  }
}
```

### Update Transaction State

```dart
// Mark a credit as collected (money returned)
final collectedCredit = creditTransaction.copyWith(
  paid: false, // Set to false when collected (net-zero effect)
  transactionState: TransactionState.completed,
  note: 'Money collected on ${DateTime.now().toString()}',
);

await transactionRepository.updateTransaction(collectedCredit);

// Mark a debt as settled (money paid back)
final settledDebt = debtTransaction.copyWith(
  paid: false, // Set to false when settled (net-zero effect)
  transactionState: TransactionState.completed,
  note: 'Debt settled on ${DateTime.now().toString()}',
);

await transactionRepository.updateTransaction(settledDebt);
```

### Working with Recurring Transactions

```dart
// Create next instance of a recurring transaction
final nextInstance = recurringTransaction.copyWith(
  id: null, // Remove ID to create new transaction
  date: DateTime.now().add(Duration(days: 30)), // Next month
  originalDateDue: recurringTransaction.originalDateDue ?? recurringTransaction.date,
  createdAnotherFutureTransaction: true,
  syncId: '', // Will generate new sync ID
);

await transactionRepository.createTransaction(nextInstance);

// Skip a recurring payment
final skippedTransaction = scheduledTransaction.copyWith(
  skipPaid: true,
  transactionState: TransactionState.cancelled,
  note: 'Payment skipped for this period',
);

await transactionRepository.updateTransaction(skippedTransaction);
```

## Advanced Filtering and Analytics

### Filter by Transaction Type

```dart
// Get all subscriptions
final allTransactions = await transactionRepository.getAllTransactions();
final subscriptions = allTransactions.where((t) => t.isSubscription).toList();

// Get all loans
final loans = allTransactions.where((t) => t.isLoan).toList();

// Get pending transactions
final pendingTransactions = allTransactions.where((t) => t.isPending).toList();

// Get transactions that need action
final actionRequired = allTransactions.where((t) => t.needsAction).toList();
```

### Calculate Loan Balances

```dart
// Calculate total money lent out (credits)
double totalCredits = 0.0;
double uncollectedCredits = 0.0;

final creditTransactions = allTransactions.where((t) => t.isCredit).toList();
for (final credit in creditTransactions) {
  totalCredits += credit.amount.abs();
  if (credit.paid) { // Still uncollected
    uncollectedCredits += credit.amount.abs();
  }
}

// Calculate total money owed (debts)
double totalDebts = 0.0;
double unsettledDebts = 0.0;

final debtTransactions = allTransactions.where((t) => t.isDebt).toList();
for (final debt in debtTransactions) {
  totalDebts += debt.amount;
  if (debt.paid) { // Still unsettled
    unsettledDebts += debt.amount;
  }
}

print('Total lent: \$${totalCredits.toStringAsFixed(2)}');
print('Uncollected: \$${uncollectedCredits.toStringAsFixed(2)}');
print('Total borrowed: \$${totalDebts.toStringAsFixed(2)}');
print('Unsettled: \$${unsettledDebts.toStringAsFixed(2)}');
```

### Monthly Subscription Analysis

```dart
// Calculate monthly subscription costs
final subscriptions = allTransactions.where((t) => t.isSubscription).toList();
double monthlySubscriptionCost = 0.0;

for (final subscription in subscriptions) {
  if (subscription.recurrence == TransactionRecurrence.monthly) {
    monthlySubscriptionCost += subscription.amount.abs();
  } else if (subscription.recurrence == TransactionRecurrence.yearly) {
    monthlySubscriptionCost += subscription.amount.abs() / 12;
  } else if (subscription.recurrence == TransactionRecurrence.weekly) {
    monthlySubscriptionCost += subscription.amount.abs() * 4.33; // Average weeks per month
  }
}

print('Monthly subscription cost: \$${monthlySubscriptionCost.toStringAsFixed(2)}');
```

## Advanced Use Cases

### Create Complex Loan with Objective Link

```dart
// For complex loans, you can link to an objective (future feature)
final complexLoan = Transaction(
  title: 'Car Loan Payment',
  note: 'Monthly payment for car loan',
  amount: -350.00,
  categoryId: transportationCategoryId,
  accountId: bankAccountId,
  date: DateTime.now(),
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
  deviceId: 'current-device-id',
  isSynced: false,
  syncId: '',
  version: 1,
  
  transactionType: TransactionType.loan,
  recurrence: TransactionRecurrence.monthly,
  periodLength: 1,
  endDate: DateTime.now().add(Duration(days: 5 * 365)), // 5 years
  objectiveLoanFk: 'car-loan-objective-id', // Link to objectives table
  transactionState: TransactionState.scheduled,
);
```

### Bulk Operations on Advanced Transactions

```dart
// Mark all overdue subscriptions as action required
final allTransactions = await transactionRepository.getAllTransactions();
final overdueSubscriptions = allTransactions.where((t) => 
  t.isSubscription && 
  t.isScheduled && 
  t.date.isBefore(DateTime.now())
).toList();

for (final subscription in overdueSubscriptions) {
  final updated = subscription.copyWith(
    transactionState: TransactionState.actionRequired,
  );
  await transactionRepository.updateTransaction(updated);
}

// Automatically collect small credits (under $10)
final smallCredits = allTransactions.where((t) => 
  t.isCredit && 
  t.needsAction && 
  t.amount.abs() < 10.0
).toList();

for (final credit in smallCredits) {
  final collected = credit.copyWith(
    paid: false,
    transactionState: TransactionState.completed,
    note: '${credit.note ?? ''}\nAuto-collected (small amount)',
  );
  await transactionRepository.updateTransaction(collected);
}
```

## Migration and Backward Compatibility

The advanced transaction features are designed to be backward compatible:

- Existing transactions will have default values:
  - `transactionType`: `TransactionType.expense` (if amount < 0) or `TransactionType.income` (if amount > 0)
  - `recurrence`: `TransactionRecurrence.none`
  - `transactionState`: `TransactionState.completed`
  - `paid`: `false`
  - All other advanced fields: `null`

- Old code will continue to work without modifications
- New features are opt-in by setting the appropriate enum values
- Database migration (schema version 4) automatically adds the new fields with safe defaults
